# Task Registry Management Patterns

Registry_Structure:
  version: "2.0.0"
  components:
    metadata:
      version: "semantic version"
      created: "ISO timestamp"
      project: "project name"
      description: "registry purpose"
    settings:
      parallel_execution_limit: 5
      auto_save_interval: 300
      critical_mode: false
      next_task_id: "auto-incrementing counter"
      next_agent_id: "auto-incrementing counter"
      default_thinking_mode: "think-hard"
      subagent_tracking: true
    sync_rules:
      update_frequency: "after_every_subtask"
      failure_mode: "halt_execution"
      validation: "checksum_verification"
      conflict_resolution: "timestamp_based"
    priority_queue:
      critical: "array of task IDs"
      high: "array of task IDs"
      medium: "array of task IDs"
      low: "array of task IDs"
    active_tasks: "object of task objects by ID"
    completed_tasks: "object of task objects by ID"
    task_locks: "object of lock info by task ID"
    execution_history: "array of events"
    thinking_metrics:
      default_mode: "think-hard"
      total_thoughts: 0
      subagent_delegations: 0
      ultrathink_uses: 0

Update_Protocol:
  steps:
    - "Read current registry state"
    - "Validate checksum to detect corruption"
    - "Apply updates to task object"
    - "Update last_updated timestamp"
    - "Calculate new checksum"
    - "Write atomically to prevent partial updates"
    - "Verify write success"
    - "Log update in execution_history"
  required_fields:
    subtask_update:
      - id: "subtask ID (e.g., 1.1)"
      - status: "pending|in_progress|completed|blocked"
      - updated_at: "ISO timestamp"
      - completed_by: "agent ID if completed"
    task_update:
      - status: "planned|in_progress|completed|blocked"
      - last_updated: "ISO timestamp"
      - progress_percentage: "calculated from subtasks"

Sync_Rules:
  frequency: "after_every_subtask"
  atomicity:
    - "Use file locking during updates"
    - "Write to temp file first"
    - "Atomic move to final location"
    - "Rollback on failure"
  validation:
    - "JSON syntax validation"
    - "Schema compliance check"
    - "Checksum verification"
    - "Task ID consistency"
  conflict_resolution:
    - "Timestamp-based ordering"
    - "Agent lock priority"
    - "Manual intervention for critical conflicts"

Validation:
  pre_update:
    - "Registry file exists"
    - "Valid JSON format"
    - "Checksum matches"
    - "Task exists in registry"
    - "Agent has lock on task"
  post_update:
    - "JSON still valid"
    - "All required fields present"
    - "Subtask IDs sequential"
    - "Status transitions valid"
    - "Timestamps monotonic"
  error_handling:
    - "Backup before updates"
    - "Restore on corruption"
    - "Alert on repeated failures"
    - "Fallback to read-only mode"

Atomic_Operations:
  file_update:
    - "Read current content"
    - "Parse and validate"
    - "Apply changes in memory"
    - "Serialize to temp file"
    - "Validate temp file"
    - "Atomic rename to target"
    - "Verify final state"
  lock_acquisition:
    - "Check current lock status"
    - "Verify no other agent holds lock"
    - "Set lock with timeout"
    - "Record lock holder and timestamp"
    - "Return success/failure"
  checksum_calculation:
    - "Sort keys consistently"
    - "Exclude volatile fields"
    - "Use SHA-256 hash"
    - "Include in registry"
    - "Validate on every read"